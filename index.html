<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Kitchatty</title>
<style>
/* Base layout */
body {
  margin: 0;
  display: flex;
  height: 100vh;
  font-family: "Segoe UI", Arial, sans-serif;
  background: linear-gradient(135deg, #091f36, #0f2862);
  color: #f5f5f5;
  overflow: hidden;
}
#app {
  display: flex;
  height: 100vh;
  overflow: hidden;
  transition: margin-right 0.3s ease;
}

#sidebar {
  width: 320px; /* make wider if needed */
  background: #0d1b3d;
  position: fixed;
  top: 0;
  right: 0;   /* right side instead of left */
  bottom: 0;
  transition: transform 0.3s ease;
  z-index: 2;
}

#sidebar.hidden {
  transform: translateX(100%); /* slide out to the right */
}

#main {
  flex: 1;
  background: #091f36;
  display: flex;
  flex-direction: column;
  margin-right: 320px; /* shift chat left to make space */
  transition: margin-right 0.3s ease;
}

#sidebar.hidden ~ #main {
  margin-right: 0; /* when sidebar hidden, chat expands */
}

#toggleSidebar {
  position: absolute;
  top: 10px;
  right: 10px; /* button on right now */
  background: #2196f3;
  border: none;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
  color: white;
  z-index: 3;
}


/* Sidebar */
#sidebar {
  width: 350px;
  background: rgba(15, 40, 98, 0.95);
  border-right: 1px solid #4f5f76;
  padding: 18px;
  overflow-y: auto;
  backdrop-filter: blur(8px);
  box-shadow: 2px 0 6px rgba(0,0,0,0.3);
}

#sidebar h3 {
  margin: 18px 0 10px;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  border-bottom: 1px solid #4f5f76;
  padding-bottom: 6px;
  letter-spacing: 0.5px;
}

.unread-badge {
  background: red;
  color: white;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 50%;
  margin-left: 4px;
  min-width: 18px;
  text-align: center;
  display: inline-block;
}

.online-user {
  padding: 10px 12px;
  border-radius: 10px;
  cursor: pointer;
  margin: 8px 0;
  transition: transform 0.2s, background 0.25s;
  background: rgba(255,255,255,0.05);
  color: #f5f5f5;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.online-user:hover { background: rgba(255,255,255,0.15); transform: translateX(4px); }
.online-user.selected { background: #4f5f76; font-weight: bold; }

.last-seen { font-size: 11px; color: #ccc; display: block; margin-top: 3px; }
.admin-badge { font-size: 11px; font-weight: bold; color: #ffcc00; margin-left: 6px; }
.friend-entry {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #1b3a73;
  padding: 8px 12px;
  border-radius: 8px;
  margin-bottom: 6px;
}

.friend-entry .avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  margin-right: 8px;
}

.friend-entry button {
  background: #2196f3;
  border: none;
  border-radius: 6px;
  padding: 4px 10px;
  color: white;
  cursor: pointer;
  font-size: 12px;
}

.friend-entry button:hover {
  background: #0d8ae5;
}

/* Small inline buttons */
.action-btn {
  margin-left: 6px;
  border: none;
  background: #4f5f76;
  color: #fff;
  padding: 3px 8px;
  font-size: 12px;
  border-radius: 6px;
  cursor: pointer;
}
.action-btn:hover { background: #6b7a98; }

/* Controls row */
#friendControls {
  display: flex;
  gap: 6px;
  align-items: center;
  margin-bottom: 8px;
}
#friendInput {
  flex: 1;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid #333;
  background: #091f36;
  color: #fff;
}
#addFriendBtn, #toggleDiscoverBtn {
  padding: 8px 10px;
  border-radius: 6px;
  border: none;
  background: linear-gradient(90deg, #386fa4, #2d4a7c);
  color: #fff;
  cursor: pointer;
  font-weight: bold;
}
#addFriendBtn:hover, #toggleDiscoverBtn:hover { filter: brightness(1.1); }

/* Chat All Button */
#chatAllBtn {
  width: 100%;
  padding: 12px;
  margin-top: 14px;
  border: none;
  background: linear-gradient(90deg, #9e363a, #7a272a);
  color: #fff;
  font-weight: bold;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}
#chatAllBtn:hover { transform: scale(1.05); box-shadow: 0 3px 10px rgba(158,54,58,0.4); }

/* Chat container */
#chatContainer {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: linear-gradient(180deg, #091f36, #0f2862);
  color: #f5f5f5;
}

/* Tabs */
#tabs {
  display: flex;
  background: #0f2862;
  border-bottom: 1px solid #4f5f76;
  padding: 6px;
  gap: 8px;
}
.tab {
  padding: 8px 12px;
  cursor: pointer;
  border-right: 1px solid #4f5f76;
  background: rgba(15, 40, 98, 0.9);
  font-size: 14px;
  display: inline-flex;
  align-items: center;
  color: #eee;
  transition: background 0.25s, color 0.25s, transform 0.2s;
  border-radius: 8px;
  gap: 8px;
}
.tab:hover { background: #4f5f76; transform: translateY(-2px); }
.tab.active {
  background: #091f36;
  font-weight: 600;
  border-bottom: 3px solid #9e363a;
  color: #fff;
}
.tab .close-btn {
  margin-left: 8px;
  color: #9e363a;
  cursor: pointer;
  font-size: 13px;
  transition: color 0.2s;
}
.tab .close-btn:hover { color: #ff5c5c; }

/* Messages list */
#notesList {
  flex: 1;
  overflow-y: auto;
  padding: 18px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* Message bubbles */
.note-item {
  max-width: 70%;
  padding: 10px 14px;
  border-radius: 16px;
  font-size: 14px;
  line-height: 1.4;
  position: relative;
  box-shadow: 0 3px 6px rgba(0,0,0,0.25);
  transition: transform 0.2s;
  display: flex;
  gap: 10px;
  align-items: center;
}
.note-item:hover { transform: translateY(-2px); }

.note-item img { width: 30px; height: 30px; border-radius: 50%; }

.note-item:not(.own-message) {
  align-self: flex-start;
  background: #4f5f76;
  color: #fff;
  border-bottom-left-radius: 4px;
}
.own-message {
  align-self: flex-end;
  background: #0f2862;
  color: #fff;
  border-bottom-right-radius: 4px;
}
.private-message {
  background: #9e363a;
  color: #fff;
  align-self: center;
  border-radius: 12px;
  font-weight: bold;
}
.admin-message { border: 2px solid #ffcc00; background: #333366; font-weight: bold; }

/* Delete button */
.note-item button {
  margin-left: 10px;
  border: none;
  background: #9e363a;
  color: #fff;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
}
.note-item button:hover { background: #7a272a; }

/* Chat bar */
#chatBar {
  display: flex;
  padding: 12px;
  background: rgba(79,95,118,0.9);
  align-items: center;
  gap: 8px;
  border-top: 1px solid #333;
  backdrop-filter: blur(6px);
}
#username {
  width: 110px;
  padding: 6px;
  border-radius: 6px;
  border: 1px solid #333;
  background: #091f36;
  color: #fff;
  text-align: center;
  font-size: 13px;
  font-weight: 500;
}
#noteInput {
  flex: 1;
  height: 38px;
  border-radius: 6px;
  border: 1px solid #333;
  padding: 0 12px;
  font-size: 14px;
  background: #0f2862;
  color: #fff;
  transition: border 0.2s, background 0.2s;
}
#noteInput:focus { border-color: #9e363a; outline: none; background: #091f36; }

#sendBtn, #logoutBtn, #attachBtn {
  padding: 0 16px;
  height: 38px;
  border-radius: 6px;
  cursor: pointer;
  background: linear-gradient(90deg, #9e363a, #7a272a);
  color: #fff;
  font-weight: bold;
  border: none;
  transition: transform 0.2s, box-shadow 0.2s;
}
#sendBtn:hover, #logoutBtn:hover, #attachBtn:hover {
  transform: translateY(-2px);
  box-shadow: 0 3px 10px rgba(158,54,58,0.4);
}
.unread-holder { display: flex; align-items: center; margin-left: 8px; }
.help { font-size: 12px; color: #ccc; margin-top: 8px; line-height: 1.3; }
.help a { color: #ffcc00; }

/* ===== Modal (News) ===== */
#newsOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
#newsModal {
  width: min(600px, 90vw);
  max-height: 80vh;
  overflow-y: auto;
  background: #0f2862;
  color: #fff;
  border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  padding: 18px 20px;
}
#newsModal header { display:flex; align-items:center; justify-content:space-between; }
#newsModal h2 { margin: 0 0 8px; }
#closeNewsBtn {
  border: none; background: #9e363a; color: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer;
}
#dontShowNewsBtn {
  border: none; background: #4f5f76; color: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer; margin-right: 8px;
}
.timestamp {
  font-size: 11px;
  color: #aaa;
  margin-left: 6px;
}
.typing-indicator {
  font-size: 12px;
  color: #5fa8d3;
  margin-top: 4px;
}

</style>
</head>
<body>
<button id="toggleSidebar">‚ò∞</button>
<div id="sidebar">
  <h3>Friends</h3>
  <div id="friendControls">
    <input id="friendInput" type="text" placeholder="Add friend by username" maxlength="32" />
    <button id="addFriendBtn">Add</button>
    <button id="toggleDiscoverBtn" title="Show/Hide all online users">Discover</button>
  </div>

  <div id="friendsList"></div>

  <h3>Friend Requests</h3>
  <div id="requestsList"></div>

  <h3 style="display:flex;align-items:center;justify-content:space-between;">Discover (All Online)
    <span style="font-size:12px;color:#ccc;">‚Äî filtered to non-friends</span>
  </h3>
  <div id="discoverList"></div>

  <button id="chatAllBtn">Chat All</button>
  <button id="editProfileBtn" style="width:100%; padding:12px; margin-top:8px; border:none; background:#4f5f76; color:#fff; font-weight:bold; border-radius:8px; cursor:pointer;" hidden>
    Edit Profile
  </button>

  <br /><br />
  <input type="color" id="bgSelector" onchange="changeBackground()" />
  <br><br>
  <button id="showNewsBtn" class="action-btn" type="button">Show News</button>
  </p>
</div>

<div id="chatContainer">
  <div id="tabs"></div>
  <div id="notesList"></div>
  <div id="chatBar">
    <input id="username" readonly />
    <input type="text" id="noteInput" placeholder="Write a message or paste a link..." />
    <button id="sendBtn">Send</button>
    <button id="attachBtn" title="Paste a URL">üìé</button>
    <button id="logoutBtn">Logout</button>
    <div id="typingIndicator" style="font-size:12px; color:#aaa; margin:4px;"></div>


  </div>
</div>

<!-- News Modal -->
<div id="newsOverlay" role="dialog" aria-modal="true" aria-labelledby="newsTitle">
  <div id="newsModal">
    <header>
      <h2 id="newsTitle">Kitchatty ‚Äî Updates</h2>
      <button id="closeNewsBtn" type="button">Close</button>
    </header>
    <div style="font-size:14px; line-height:1.5;">
      <p><strong>What‚Äôs new:</strong></p>
      <ul>
        <li>‚ú® Brand new Friends system (add/accept/remove + requests)</li>
        <li>üóÇÔ∏è Sidebar is decluttered ‚Äî only shows your friends by default</li>
        <li>üõ°Ô∏è Profanity filter & 350 character limit</li>
        <li>üñºÔ∏è Free attachments via pasted links (Imgur/Postimages etc.)</li>
        <li>üì£ This news pops up the first time you open the page</li>
      </ul>
      <p style="opacity:.8;">Tip: Use <em>Discover</em> to see everyone currently online and add them as friends.</p>
      <div style="margin-top:10px; display:flex; justify-content:flex-end; gap:8px;">
        <button id="dontShowNewsBtn" type="button">Don‚Äôt show again</button>
        <button id="ackNewsBtn" class="action-btn" type="button">Got it</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ===== Firebase ===== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import {
  getFirestore, collection, addDoc, onSnapshot,
  deleteDoc, doc, query, orderBy, setDoc,
  updateDoc, arrayUnion, arrayRemove, serverTimestamp, getDoc
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

/* ===== Firebase (Spark-plan friendly: no Storage) ===== */
const firebaseConfig = {
  apiKey: "AIzaSyBXhiyGWev_pgR04Xqwq-09cE_oyrLWnU8",
  authDomain: "kitisnotebook.firebaseapp.com",
  projectId: "kitisnotebook",
  // storageBucket intentionally omitted for free plan
  messagingSenderId: "450680847245",
  appId: "1:450680847245:web:2e4ebb71ccd3a7920bdbc4",
  measurementId: "G-W3ZVV6N6KK"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ===== Admin & login ===== */
const ADMIN_USER = "kitis";
let isAdmin = false;
const loggedInUser = localStorage.getItem("loggedInUser");
if (!loggedInUser) window.location.href = "login.html";
(document.getElementById("username")).value = loggedInUser;
if (loggedInUser === ADMIN_USER) isAdmin = true;
// Ensure my user doc exists so friends can reference me
await setDoc(doc(db, "users", loggedInUser), { createdAt: Date.now() }, { merge: true });

/* ===== Helpers ===== */
const looksLikeUrl = (text = "") => /^https?:\/\/\S+$/i.test(text.trim());
const isImageUrl = (str = "") => /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(str.split(/[?#]/)[0]);
const isGroupKey = (k) => typeof k === "string" && k.startsWith("group:");
const groupNameFromKey = (k) => (k.split(":")[1] || "").trim();
const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

function formatLastSeen(ms) {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) return "just now";
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} min ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hr ago`;
  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}

/* ===== Profanity filter ===== */
const bannedWords = [
  "fuck","bitch","pussy","cock","cum","slut","whore",
  "france","french","british","asshole","dick","cunt","bastard","motherfucker",
  "nigger","nigga","chink","spic","fag","faggot","retard"
];
function filterProfanity(text) {
  let filtered = text;
  bannedWords.forEach((w) => {
    const regex = new RegExp(w, "gi");
    filtered = filtered.replace(regex, "****");
  });
  return filtered;
}

/* ===== Presence ===== */
const friendsList = document.getElementById("friendsList");
const requestsList = document.getElementById("requestsList");
const discoverList = document.getElementById("discoverList");

// Track who is online + their meta
let presence = {}; // { username: { lastActive:number, avatar:string } }

// Friends state
let friendsAccepted = new Set();
let friendsPendingOut = new Set(); // I sent
let friendsRequestedIn = new Set(); // They sent

// Listen to online presence
onSnapshot(collection(db, "onlineUsers"), (snapshot) => {
  const now = Date.now();
  const map = {};
  snapshot.forEach((docSnap) => {
    const data = docSnap.data();
    const user = data.username;
    if (!user || user === loggedInUser) return; // hide self
    map[user] = {
      lastActive: data.lastActive || 0,
      avatar: data.avatar || `https://i.pravatar.cc/30?u=${user}`,
      online: now - (data.lastActive || 0) <= 60 * 1000
    };
  });
  presence = map;
  renderFriends();
  renderDiscover();
});

/* ===== Friends subcollection ===== */
const myFriendsCol = collection(db, "users", loggedInUser, "friends");

onSnapshot(myFriendsCol, (snap) => {
  friendsAccepted = new Set();
  friendsPendingOut = new Set();
  friendsRequestedIn = new Set();

  snap.forEach((docSnap) => {
    const friend = docSnap.id;
    const data = docSnap.data();
    const status = (data && data.status) || "";
    if (status === "accepted") friendsAccepted.add(friend);
    else if (status === "pending") friendsPendingOut.add(friend);
    else if (status === "requested") friendsRequestedIn.add(friend);
  });

  renderFriends();
  renderRequests();
  renderDiscover();
});



async function respondToFriendRequest(fromUser, accept) {
  const myRef = doc(db, "users", loggedInUser, "friends", fromUser);
  const theirRef = doc(db, "users", fromUser, "friends", loggedInUser);
  try {
    if (accept) {
      await updateDoc(myRef, { status: "accepted" });
      await updateDoc(theirRef, { status: "accepted" });
    } else {
      await deleteDoc(myRef);
      await deleteDoc(theirRef);
    }
  } catch (e) {
    console.error(e);
    alert("Failed to update request.");
  }
}

async function cancelFriendRequest(user) {
  const myRef = doc(db, "users", loggedInUser, "friends", user);
  const theirRef = doc(db, "users", user, "friends", loggedInUser);
  try {
    await deleteDoc(myRef);
    await deleteDoc(theirRef);
  } catch (e) {
    console.error(e);
    alert("Failed to cancel request.");
  }
}

async function removeFriend(user) {
  if (!confirm(`Remove ${user} from friends?`)) return;
  const myRef = doc(db, "users", loggedInUser, "friends", user);
  const theirRef = doc(db, "users", user, "friends", loggedInUser);
  try {
    await deleteDoc(myRef);
    await deleteDoc(theirRef);
  } catch (e) {
    console.error(e);
    alert("Failed to remove friend.");
  }
}

/* ===== Rendering ===== */
function sortUsersByPresence(usernames) {
  const now = Date.now();
  return [...usernames].sort((a, b) => {
    const A = presence[a] || {}; const B = presence[b] || {};
    const aOnline = A.lastActive ? now - A.lastActive <= 60*1000 : false;
    const bOnline = B.lastActive ? now - B.lastActive <= 60*1000 : false;
    if (aOnline && !bOnline) return -1;
    if (!aOnline && bOnline) return 1;
    return (B.lastActive || 0) - (A.lastActive || 0);
  });
}

function buildUserRow(user, opts = {}) {
  const meta = presence[user] || { lastActive: 0, avatar: `https://i.pravatar.cc/30?u=${user}` };
  const div = document.createElement("div");
  div.className = "online-user";
  div.dataset.user = user;

  const avatar = document.createElement("img");
  avatar.src = meta.avatar;
  avatar.className = "avatar";

  const info = document.createElement("span");
  info.textContent = `${user} ${meta.online ? "(online)" : "(last seen " + timeAgo(meta.lastActive) + ")"}`;

  const right = document.createElement("div");
  right.className = "actions";

  // Add optional action buttons
  (opts.buttons || []).forEach((btnDef) => {
    const b = document.createElement("button");
    b.className = "action-btn";
    b.textContent = btnDef.text;
    b.onclick = (e) => {
      e.stopPropagation(); // stop row click
      btnDef.onClick && btnDef.onClick();
    };
    right.appendChild(b);
  });

  div.appendChild(avatar);
  div.appendChild(info);
  div.appendChild(right);

  // Only allow row click if not explicitly disabled
  if (!opts.preventRowClick) {
    div.onclick = () => openTab(user);
  }

  return div;
}



function renderFriends() {
  friendsList.innerHTML = "";

  // All Chat pseudo-row
  const allDiv = document.createElement("div");
  allDiv.className = "online-user";
  allDiv.dataset.user = "all";
  const leftAll = document.createElement("div");
  leftAll.style.display = "flex";
  leftAll.style.flexDirection = "column";
  const labelAll = document.createElement("span");
  labelAll.textContent = "All Chat";
  leftAll.appendChild(labelAll);
  allDiv.appendChild(leftAll);
  const rightAll = document.createElement("div");
  rightAll.style.display = "flex";
  rightAll.style.alignItems = "center";
  const unreadHolderAll = document.createElement("span");
  unreadHolderAll.className = "unread-holder";
  rightAll.appendChild(unreadHolderAll);
  allDiv.appendChild(rightAll);
  allDiv.onclick = () => openTab("all");
  friendsList.appendChild(allDiv);
  updateUnreadBadge("all");

  const sorted = sortUsersByPresence(friendsAccepted);
  sorted.forEach((user) => {
    const row = buildUserRow(user, {
      buttons: [
        { text: "Chat", title: "Open chat", onClick: () => openTab(user) },
        { text: "‚àí", title: "Remove friend", onClick: () => removeFriend(user) },
      ],
    });
    friendsList.appendChild(row);
    updateUnreadBadge(user);
  });

  if (!sorted.length) {
    const hint = document.createElement("div");
    hint.style.fontSize = "12px";
    hint.style.color = "#ccc";
    hint.style.marginTop = "6px";
    hint.innerHTML = "No friends yet. Use <strong>Discover</strong> or add by username above.";
    friendsList.appendChild(hint);
  }
}

function renderRequests() {
  requestsList.innerHTML = "";

  // Incoming requests (requested -> me)
sortUsersByPresence(friendsRequestedIn).forEach((user) => {
  const row = buildUserRow(user, {
    buttons: [
      { text: "Accept", onClick: () => respondToFriendRequest(user, true) },
      { text: "Reject", onClick: () => respondToFriendRequest(user, false) },
    ],
    preventRowClick: true
  });
  requestsList.appendChild(row);
});

  // Outgoing pending (I sent)
  sortUsersByPresence(friendsPendingOut).forEach((user) => {
    const row = buildUserRow(user, {
      buttons: [
        { text: "Pending‚Ä¶", title: "Waiting for response", onClick: () => {} },
        { text: "Cancel", onClick: () => cancelFriendRequest(user) },
      ],
      preventRowClick: true
    });
    requestsList.appendChild(row);
  });

  // Show placeholder if no requests
  if (!friendsRequestedIn.size && !friendsPendingOut.size) {
    const none = document.createElement("div");
    none.style.fontSize = "12px";
    none.style.color = "#ccc";
    none.textContent = "No pending requests.";
    requestsList.appendChild(none);
  }
}


function renderDiscover() {
  const allOnline = new Set(Object.keys(presence));
  const notFriends = [...allOnline].filter(
    (u) => !friendsAccepted.has(u) && u !== loggedInUser
  );
  const sorted = sortUsersByPresence(notFriends);

  discoverList.innerHTML = "";
  sorted.forEach((user) => {
    const alreadyPending = friendsPendingOut.has(user);
    const alreadyIncoming = friendsRequestedIn.has(user);

    const row = buildUserRow(user, {
      buttons: [
        alreadyPending
          ? { text: "Pending‚Ä¶", onClick: () => {} }
          : alreadyIncoming
          ? { text: "Accept", onClick: () => respondToFriendRequest(user, true) }
          : { text: "Add", onClick: () => sendFriendRequest(user) },
      ],
      preventRowClick: true, // disable row click for discover list
    });

    discoverList.appendChild(row);
  });

  if (!sorted.length) {
    const msg = document.createElement("div");
    msg.style.fontSize = "12px";
    msg.style.color = "#ccc";
    msg.textContent = "No one to discover right now.";
    discoverList.appendChild(msg);
  }
}


async function sendFriendRequest(toUser) {
  if (!toUser || toUser === loggedInUser) return;
  const myRef = doc(db, "users", loggedInUser, "friends", toUser);
  const theirRef = doc(db, "users", toUser, "friends", loggedInUser);

  try {
    await setDoc(myRef, { status: "pending" });
    await setDoc(theirRef, { status: "requested" });
  } catch (err) {
    console.error(err);
    alert("Failed to send friend request.");
  }
}

/* Controls */
document.getElementById("addFriendBtn").onclick = () => {
  const input = document.getElementById("friendInput");
  sendFriendRequest(input.value);
  input.value = "";
};

const toggleDiscoverBtn = document.getElementById("toggleDiscoverBtn");
toggleDiscoverBtn.onclick = () => {
  const isHidden = getComputedStyle(discoverList).display === "none";
  discoverList.style.display = isHidden ? "block" : "none";
};

/* ===== Presence: mark myself online ===== */
async function goOnline() {
  const userRef = doc(db, "onlineUsers", loggedInUser);
  await setDoc(userRef, {
    username: loggedInUser,
    lastActive: Date.now(),
    avatar: "https://i.pravatar.cc/30?u=" + loggedInUser,
  });
}
goOnline();
setInterval(async () => {
  const userRef = doc(db, "onlineUsers", loggedInUser);
  await setDoc(
    userRef,
    { username: loggedInUser, lastActive: Date.now(), avatar: `https://i.pravatar.cc/30?u=${loggedInUser}` },
    { merge: true }
  );
}, 30000);

/* Optional profile live updates for current user avatar/status (guarded) */
onSnapshot(doc(db, "profiles", loggedInUser), (snap) => {
  if (!snap.exists()) return;
  const data = snap.data();
  const userDiv = document.querySelector(`.online-user[data-user="${CSS.escape(loggedInUser)}"]`);
  if (!userDiv) return; // we don't render self in lists
  const img = userDiv.querySelector("img");
  if (img) img.src = data.avatar || `https://i.pravatar.cc/30?u=${loggedInUser}`;
  const label = userDiv.querySelector("span");
  if (label) label.textContent = `${loggedInUser} - ${data.status || ""}`;
});

/* ===== Groups: UI + Data ===== */
const sidebar = document.getElementById("sidebar");
const groupsHeader = document.createElement("h3");
groupsHeader.textContent = "Groups";
const groupsList = document.createElement("div");
groupsList.id = "groupsList";

const newGroupBtn = document.createElement("button");
newGroupBtn.id = "newGroupBtn";
newGroupBtn.textContent = "+ New Group";
newGroupBtn.style.cssText = `
  width: 100%; padding: 12px; margin-top: 8px; border: none;
  background: linear-gradient(90deg, #386fa4, #2d4a7c); color: #fff;
  font-weight: bold; border-radius: 8px; cursor: pointer;
  transition: transform .2s, box-shadow .2s;
`;
newGroupBtn.onmouseenter = () => (newGroupBtn.style.boxShadow = "0 3px 10px rgba(56,111,164,0.4)");
newGroupBtn.onmouseleave = () => (newGroupBtn.style.boxShadow = "");

discoverList.insertAdjacentElement("afterend", groupsHeader);
groupsHeader.insertAdjacentElement("afterend", groupsList);
groupsList.insertAdjacentElement("afterend", newGroupBtn);

let myGroups = new Set();                 // e.g., "group:friends"
let groupsMeta = {};                      // key -> { id, members, createdBy, createdAt }

function parseMembers(raw) {
  if (!raw) return [];
  const arr = raw.split(",").map(s => s.trim()).filter(Boolean);
  const unique = Array.from(new Set(arr)).filter(u => u.length <= 32);
  return unique;
}

newGroupBtn.onclick = async () => {
  let name = prompt("Enter a group name (letters, numbers, -, _ ; max 30 chars):");
  if (!name) return;
  name = name.trim().toLowerCase().replace(/[^\w-]+/g, "-").replace(/^-+|-+$/g, "");
  if (!name) return alert("Invalid name.");
  if (name.length > 30) name = name.slice(0, 30);

  const extra = prompt("Add members (comma-separated usernames), optional:");
  const members = parseMembers(extra).filter(u => u !== loggedInUser);
  try {
    await setDoc(doc(db, "groups", name), {
      members: [loggedInUser],
      createdBy: loggedInUser,
      createdAt: Date.now()
    }, { merge: true });
    if (members.length) {
      await updateDoc(doc(db, "groups", name), { members: arrayUnion(...members) });
    }
    openTab(`group:${name}`);
  } catch (e) {
    console.error(e);
    alert("Could not create group. Check console for details.");
  }
};

// Live groups list (incremental render could be added later; keep simple for now)
onSnapshot(collection(db, "groups"), (snap) => {
  groupsList.innerHTML = "";
  myGroups = new Set();
  groupsMeta = {};

  snap.forEach((docSnap) => {
    const g = docSnap.data();
    const id = docSnap.id;
    const key = `group:${id}`;
    if (!Array.isArray(g.members)) return;

    if (g.members.includes(loggedInUser)) {
      myGroups.add(key);
      groupsMeta[key] = { id, ...g };

      const div = document.createElement("div");
      div.className = "online-user";
      div.dataset.user = key;

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.flexDirection = "column";
      const label = document.createElement("span");
      label.textContent = `#${id}`;
      left.appendChild(label);

      const small = document.createElement("span");
      small.className = "last-seen";
      small.textContent = `${g.members.length} member${g.members.length === 1 ? "" : "s"}`;
      left.appendChild(small);
      div.appendChild(left);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";

      const unreadHolder = document.createElement("span");
      unreadHolder.className = "unread-holder";
      right.appendChild(unreadHolder);
        
      const mkBtn = (txt, title) => {
        const b = document.createElement("button");
        b.textContent = txt;
        b.title = title;
        b.className = "action-btn";
        return b;
      };

      const inviteBtn = mkBtn("Ôºã", "Invite members");
      inviteBtn.onclick = async (e) => {
        e.stopPropagation();
        const raw = prompt("Usernames to invite (comma-separated):");
        const toAdd = parseMembers(raw).filter(Boolean);
        if (!toAdd.length) return;
        try { await updateDoc(doc(db, "groups", id), { members: arrayUnion(...toAdd) }); }
        catch (err) { console.error(err); alert("Failed to invite."); }
      };
      right.appendChild(inviteBtn);

      const leaveBtn = mkBtn("‚éã", "Leave group");
      leaveBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm(`Leave #${id}?`)) return;
        try {
          await updateDoc(doc(db, "groups", id), { members: arrayRemove(loggedInUser) });
          if (activeTab === key) {
            activeTab = "all"; highlightActiveTab(); displayMessages();
          }
        } catch (err) { console.error(err); alert("Failed to leave."); }
      };
      right.appendChild(leaveBtn);

      const canDelete = (g.createdBy === loggedInUser) || isAdmin;
      if (canDelete) {
        const delBtn = mkBtn("üóë", "Delete group");
        delBtn.onclick = async (e) => {
          e.stopPropagation();
          if (!confirm(`Delete #${id} for everyone? This removes history (within retention window).`)) return;
          try {
            await deleteDoc(doc(db, "groups", id));
            if (activeTab === key) {
              activeTab = "all"; highlightActiveTab(); displayMessages();
            }
          } catch (err) { console.error(err); alert("Failed to delete group."); }
        };
        right.appendChild(delBtn);
      }

      div.appendChild(right);
      div.onclick = () => openTab(key);

      groupsList.appendChild(div);
      updateUnreadBadge(key);
    }
  });
});

/* ===== Tabs ===== */
const tabsContainer = document.getElementById("tabs");
let openTabs = {};
let activeTab = "all";

function labelForTab(key) {
  if (key === "all") return "All Chat";
  if (isGroupKey(key)) return `#${groupNameFromKey(key)}`;
  return key;
}

function openTab(key) {
  if (!openTabs[key]) {
    const tab = document.createElement("div");
    tab.className = "tab" + (key === activeTab ? " active" : "");
    tab.dataset.user = key;
    tab.textContent = labelForTab(key);

    if (key !== "all") {
      const closeBtn = document.createElement("span");
      closeBtn.textContent = "‚úñ";
      closeBtn.className = "close-btn";
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        tabsContainer.removeChild(tab);
        delete openTabs[key];
        if (activeTab === key) { activeTab = "all"; highlightActiveTab(); displayMessages(); }
      };
      tab.appendChild(closeBtn);
    }

    tab.onclick = () => {
      activeTab = key;
      if (unreadCounts[key]) unreadCounts[key] = 0;
      if (unreadMessageIds[key]) unreadMessageIds[key].clear();
      updateUnreadBadge(key);
      highlightActiveTab();
      displayMessages();
    };

    openTabs[key] = tab;
    tabsContainer.appendChild(tab);
    updateUnreadBadge(key);
  }

  activeTab = key;
  if (unreadCounts[key]) unreadCounts[key] = 0;
  if (unreadMessageIds[key]) unreadMessageIds[key].clear();
  updateUnreadBadge(key);
  highlightActiveTab();
  displayMessages();
}
function highlightActiveTab() {
  Object.values(openTabs).forEach((tab) => tab.classList.remove("active"));
  if (openTabs[activeTab]) openTabs[activeTab].classList.add("active");
}
// --- Unified sendMessage with typing + timestamp support ---
async function sendMessage() {
  let text = document.getElementById("noteInput").value.trim();
  if (!text) return;

  const isDM = !isGroupKey(activeTab) && activeTab !== "all";
  const isFriend = friendsAccepted.has(activeTab);

  if (isDM && !isFriend) {
    alert("You can only message users you are friends with.");
    return;
  }

  // Prevent posting to groups you left
  if (isGroupKey(activeTab) && !myGroups.has(activeTab)) {
    alert("You are not a member of this group.");
    return;
  }

  const targetIsGroup = isGroupKey(activeTab);
  const groupId = targetIsGroup ? groupNameFromKey(activeTab) : null;

  // Pick the right collection
  const msgCol = targetIsGroup
    ? collection(db, "groups", groupId, "messages")
    : collection(db, "messages");

  // Handle URLs as attachments
  if (looksLikeUrl(text)) {
    await addDoc(msgCol, {
      text: "",
      from: loggedInUser,
      to: activeTab,
      timestamp: Date.now(),
      fileURL: text,
      fileName: text.split("/").pop().split("?")[0],
    });
    document.getElementById("noteInput").value = "";
    // reset typing
    await setDoc(doc(db, "presence", loggedInUser), { typing: false }, { merge: true });
    return;
  }

  const maxLength = 350;
  if (text.length > maxLength) {
    alert(`Message too long! Limit is ${maxLength} characters.`);
    return;
  }

  text = filterProfanity(text);

  await addDoc(msgCol, {
    text,
    from: loggedInUser,
    to: activeTab,
    timestamp: Date.now(),
  });

  document.getElementById("noteInput").value = "";

  // reset typing after sending
  await setDoc(doc(db, "presence", loggedInUser), { typing: false }, { merge: true });
}


document.getElementById("toggleSidebar").addEventListener("click", () => {
  const sidebar = document.getElementById("sidebar");
  const main = document.getElementById("main");

  sidebar.classList.toggle("hidden");

  if (sidebar.classList.contains("hidden")) {
    main.style.marginLeft = "0";
  } else {
    main.style.marginLeft = "320px"; // same width as sidebar
  }
});


document.getElementById("sendBtn").onclick = sendMessage;
document.getElementById("noteInput").addEventListener("keydown", (e) => {
  if (e.key === "Enter") { e.preventDefault(); sendMessage(); }
});

const q = query(collection(db, "messages"), orderBy("timestamp"));
onSnapshot(q, (snapshot) => {
  snapshot.docChanges().forEach((change) => {
    const data = change.doc.data();
    const id = change.doc.id;

    if (change.type === "added") {
      if (!data || typeof data.timestamp !== "number") return;
      mergeMessage({ id, data });
    }

    if (change.type === "modified") {
      if (!data || typeof data.timestamp !== "number") return;
      mergeMessage({ id, data }); // update content if edited
    }

    if (change.type === "removed") {
      // Remove from messagesByTab
      Object.keys(messagesByTab).forEach((key) => {
        messagesByTab[key] = messagesByTab[key].filter(m => m.id !== id);
        // Also update unread if needed
        if (unreadMessageIds[key]) unreadMessageIds[key].delete(id);
      });
    }
  });

  displayMessages();
});


/* ===== Group message listeners ===== */
let groupUnsubs = {};

function setupGroupListeners() {
  // remove old listeners
  Object.values(groupUnsubs).forEach(unsub => unsub());
  groupUnsubs = {};

  myGroups.forEach((key) => {
  const groupId = groupNameFromKey(key);
  const q = query(collection(db, "groups", groupId, "messages"), orderBy("timestamp"));

  groupUnsubs[key] = onSnapshot(q, (snapshot) => {
  snapshot.docChanges().forEach((change) => {
    const data = change.doc.data();
    const id = change.doc.id;

    if (change.type === "added" || change.type === "modified") {
      if (!data || typeof data.timestamp !== "number") return;
      mergeMessage({ id, data });
    }

    if (change.type === "removed") {
      if (!messagesByTab[key]) return;
      messagesByTab[key] = messagesByTab[key].filter(m => m.id !== id);
      if (unreadMessageIds[key]) unreadMessageIds[key].delete(id);
    }
  });

  displayMessages();
});

});

}

// Call it whenever groups membership changes
onSnapshot(collection(db, "groups"), (snap) => {
  // ‚Ä¶ your existing groups list rebuild ‚Ä¶
  setupGroupListeners();
});

/* ===== Messages ===== */
const notesList = document.getElementById("notesList");
let allMessages = [];  // ‚Üê Add this so displayMessages can use it

/* Unread tracking */
let unreadCounts = {};
let unreadMessageIds = {}; // { key: Set<messageId> }

// Track messages separately to avoid duplicates
let messagesByTab = {}; // key = "all", username, or group:groupName, value = array of messages

function displayMessages() {
  notesList.innerHTML = "";

  // Get the messages for the current tab only
  const tabKey = activeTab;
  const messages = messagesByTab[tabKey] || [];

  messages.forEach(({ id, data }) => {
    renderMessage({ id }, data);

    // Mark as read in unread tracking
    if (unreadMessageIds[tabKey]) unreadMessageIds[tabKey].delete(id);
  });

  notesList.scrollTop = notesList.scrollHeight;

  // Update unread badges
  Object.keys(unreadCounts).forEach((key) => updateUnreadBadge(key));
}

// Add a helper to merge new messages into messagesByTab
function mergeMessage(msg) {
  const { id, data } = msg;
  let key;

  if (isGroupKey(data.to)) key = data.to;
  else if (data.to === "all") key = "all";
  else key = data.from === loggedInUser ? data.to : data.from;

  if (!messagesByTab[key]) messagesByTab[key] = [];
  messagesByTab[key] = messagesByTab[key].filter(m => m.id !== id); // remove duplicates
  messagesByTab[key].push(msg);

  // Track unread
  const isDMToMe = key !== "all" && !isGroupKey(key) && data.to === loggedInUser && data.from !== loggedInUser;
  if ((isDMToMe || (key === "all" && data.from !== loggedInUser) || (isGroupKey(key) && data.from !== loggedInUser && !myGroups.has(key)))) {
    if (!unreadMessageIds[key]) unreadMessageIds[key] = new Set();
    if (!unreadMessageIds[key].has(id)) {
      unreadMessageIds[key].add(id);
      unreadCounts[key] = (unreadCounts[key] || 0) + 1;
    }
  }
}



function renderMessage(docSnap, data) {
  const div = document.createElement("div");
  div.className = "note-item";

  const avatarImg = document.createElement("img");
  avatarImg.src = `https://i.pravatar.cc/30?u=${data.from}`;
  div.appendChild(avatarImg);

  const content = document.createElement("span");

  if (isGroupKey(data.to)) {
    const gName = groupNameFromKey(data.to);
    content.textContent = `#${gName} ‚Ä¢ ${data.from}: ${data.text || (data.fileName ? data.fileName : "")}`;
  } else if (data.to !== "all" && data.to !== loggedInUser && data.from === loggedInUser) {
    content.textContent = `${data.from} ‚Üí ${data.to}: ${data.text || (data.fileName ? data.fileName : "")}`;
  } else {
    content.textContent = `${data.from}: ${data.text || (data.fileName ? data.fileName : "")}`;
  }
  div.appendChild(content);

  // --- File attachments (your existing code) ---
  if (data.fileURL) {
    const sep = document.createTextNode(" ");
    div.appendChild(sep);

    const fileLink = document.createElement("a");
    fileLink.href = data.fileURL;
    fileLink.target = "_blank";
    fileLink.rel = "noopener noreferrer";
    fileLink.textContent = data.fileName || "File";
    fileLink.style.color = "#ffcc00";
    fileLink.style.textDecoration = "underline";
    div.appendChild(fileLink);

    if (isImageUrl(data.fileURL)) {
      const preview = document.createElement("img");
      preview.src = data.fileURL;
      preview.alt = data.fileName || "attachment";
      preview.style.width = "120px";
      preview.style.height = "auto";
      preview.style.borderRadius = "8px";
      preview.style.marginLeft = "8px";
      preview.style.cursor = "pointer";
      preview.onclick = () => window.open(data.fileURL, "_blank");
      div.appendChild(preview);
    }
  }

  // --- Timestamp (new) ---
  if (data.timestamp) {
    const timeSpan = document.createElement("span");
    timeSpan.className = "timestamp";
    timeSpan.style.marginLeft = "8px";
    timeSpan.style.fontSize = "11px";
    timeSpan.style.color = "#aaa";
    timeSpan.textContent = timeAgo(data.timestamp); // uses your timeAgo() helper
    div.appendChild(timeSpan);
  }

  // --- Styling for special cases ---
  if (data.from === ADMIN_USER) div.classList.add("admin-message");
  if (data.from === loggedInUser) div.classList.add("own-message");
  else if (data.to === loggedInUser && data.to !== "all") div.classList.add("private-message");

  // --- Delete button ---
  if (data.from === ADMIN_USER || data.from === loggedInUser || isAdmin) {
    const delBtn = document.createElement("button");
    delBtn.textContent = "Delete";
    delBtn.onclick = () => deleteDoc(doc(db, "messages", docSnap.id));
    div.appendChild(delBtn);
  }

  notesList.appendChild(div);
}


function updateUnreadBadge(key) {
  const count = clamp(unreadCounts[key] || 0, 0, 999);
  const formatCount = (n) => (n > 99 ? "99+" : n);
  function createUnreadBadge(n) {
    const badge = document.createElement("span");
    badge.className = "unread-badge";
    badge.textContent = formatCount(n);
    badge.setAttribute("aria-label", `${n} unread message${n === 1 ? "" : "s"}`);
    return badge;
  }

  if (openTabs[key]) {
    const tab = openTabs[key];
    let badge = tab.querySelector(".unread-badge");
    if (count > 0) { if (!badge) tab.appendChild(createUnreadBadge(count)); else badge.textContent = formatCount(count); }
    else if (badge) badge.remove();
  }

  const row = document.querySelector(`.online-user[data-user="${CSS.escape(key)}"]`);
  if (row) {
    const holder = row.querySelector(".unread-holder");
    if (holder) {
      let badge = holder.querySelector(".unread-badge");
      if (count > 0) { if (!badge) holder.appendChild(createUnreadBadge(count)); else badge.textContent = formatCount(count); }
      else if (badge) badge.remove();
    }
  }
}

/* Init */
document.getElementById("chatAllBtn").onclick = () => openTab("all");
openTab("all");

/* Logout */
document.getElementById("logoutBtn").onclick = async () => {
  try { await deleteDoc(doc(db, "onlineUsers", loggedInUser)); } catch(_) {}
  localStorage.removeItem("loggedInUser");
  window.location.href = "login.html";
};

/* Attachments (paste a URL) */
const attachBtn = document.getElementById("attachBtn");
attachBtn.onclick = async () => {
  const url = prompt("Paste a direct link to an image/file (e.g., https://i.imgur.com/abc123.png):");
  if (!url) return;
  await addDoc(collection(db, "messages"), {
    text: "",
    from: loggedInUser,
    to: activeTab,
    timestamp: Date.now(),
    fileURL: url,
    fileName: url.split("/").pop().split("?")[0],
  });
};

/* Inline color picker */
window.changeBackground = function changeBackground() {
  const notesList2 = document.getElementById("notesList");
  const val = document.getElementById("bgSelector").value;
  notesList2.style.backgroundColor = val;
};

/* News modal behavior */
const NEWS_VERSION = "1"; // bump when you change content
const newsOverlay = document.getElementById("newsOverlay");
const showNews = () => { newsOverlay.style.display = "flex"; };
const hideNews = () => { newsOverlay.style.display = "none"; };

// Open once if not seen
if (localStorage.getItem("kitchatty_news_version") !== NEWS_VERSION) {
  showNews();
}

document.getElementById("closeNewsBtn").onclick = hideNews;
document.getElementById("ackNewsBtn").onclick = () => { hideNews(); localStorage.setItem("kitchatty_news_version", NEWS_VERSION); };
document.getElementById("dontShowNewsBtn").onclick = () => { localStorage.setItem("kitchatty_news_version", NEWS_VERSION); hideNews(); };
document.getElementById("showNewsBtn").onclick = showNews;

// Escape key closes
window.addEventListener("keydown", (e) => { if (e.key === "Escape") hideNews(); });

/* Lightweight runtime checks */
console.assert(typeof window.changeBackground === "function", "changeBackground not attached to window");
console.assert(typeof addDoc === "function", "Firestore import missing");

/* === Typing Indicator + Messages with Timestamps === */

// Utility: how long ago
function timeAgo(ts) {
  const seconds = Math.floor((Date.now() - ts) / 1000);
  if (seconds < 60) return "just now";
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} minute${minutes > 1 ? "s" : ""} ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hour${hours > 1 ? "s" : ""} ago`;
  const days = Math.floor(hours / 24);
  return `${days} day${days > 1 ? "s" : ""} ago`;
}

const messageInput = document.getElementById("noteInput");  // use the same input as sending
const typingIndicator = document.getElementById("typingIndicator");


let typingTimeout;

// --- Typing state updates ---
messageInput.addEventListener("input", () => {
  setDoc(doc(db, "presence", loggedInUser), { typing: true }, { merge: true });

  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    setDoc(doc(db, "presence", loggedInUser), { typing: false }, { merge: true });
  }, 3000);
});

// Watch a friend‚Äôs typing status
function watchFriendTyping(friendUser) {
  onSnapshot(doc(db, "presence", friendUser), (snap) => {
    const data = snap.data();
    if (data?.typing) {
      typingIndicator.textContent = `${friendUser} is typing...`;
    } else {
      typingIndicator.textContent = "";
    }
  });
}

// --- Listen for new messages in a chat ---
function watchMessages(chatId) {
  onSnapshot(
    collection(db, "chats", chatId, "messages"),
    (snap) => {
      messagesContainer.innerHTML = "";
      snap.forEach((docSnap) => {
        renderMessage(docSnap.data());
      });
    }
  );
}

</script>

</body>
</html>

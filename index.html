<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Kitchatty</title>
<style>
/* ===== Base Layout ===== */
body {
  margin: 0;
  display: flex;
  height: 100vh;
  font-family: "Segoe UI", Arial, sans-serif;
  background: linear-gradient(135deg, #091f36, #0f2862);
  color: #f5f5f5;
  overflow: hidden;
}

#app {
  display: flex;
  flex: 1;
  overflow: hidden;
  transition: margin-right 0.4s ease;
}

#main {
  flex: 1;
  display: flex;
  flex-direction: column;
  margin-right: 0; /* sidebar hidden initially */
  background: #091f36;
  transition: margin-right 0.4s ease;
}

/* ===== Sidebar ===== */
#sidebar {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 360px;
  background: #0f1f38;
  border-top-left-radius: 16px;
  border-bottom-left-radius: 16px;
  box-shadow: -3px 0 25px rgba(0,0,0,0.45);
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 15px;
  overflow-y: auto;
  transform: translateX(100%);
  opacity: 0; /* hide completely */
  pointer-events: none; /* ignore clicks when hidden */
  transition: all 0.4s ease;
  z-index: 900; /* make sure it's above chat but below toggle button */
}

#sidebar.visible {
  transform: translateX(0);
  opacity: 1; /* show fully */
  pointer-events: auto; /* allow clicks */
}

/* Scrollbar for sidebar */
#sidebar::-webkit-scrollbar {
  width: 8px;
}
#sidebar::-webkit-scrollbar-track {
  background: #0f1f38;
}
#sidebar::-webkit-scrollbar-thumb {
  background: #3a82f7;
  border-radius: 4px;
}

#sidebar:hover {
  box-shadow: -3px 0 35px rgba(0,0,0,0.55);
}

#sidebar h3 {
  margin: 18px 0 10px;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  border-bottom: 1px solid #4f5f76;
  padding-bottom: 6px;
  letter-spacing: 0.5px;
}

/* ===== Sidebar Toggle Button ===== */
#toggleSidebar {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #3a82f7;
  border: none;
  color: white;
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 14px rgba(0,0,0,0.35);
  transition: all 0.2s;
  z-index: 1000;
}

#toggleSidebar:hover {
  background: #2e6fd1;
  transform: scale(1.1);
}

/* ===== Online Users ===== */
.online-user {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 14px;
  background: #14254d;
  border-radius: 14px;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.online-user:hover {
  background: #1e3a73;
  transform: translateX(2px);
}

.online-user.selected {
  background: #3a82f7;
  font-weight: 600;
}

.online-user .avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: 2px solid #3a82f7;
}

.online-user .user-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex: 1;
}

.online-user .username {
  font-weight: 500;
  font-size: 14px;
  color: #fff;
}

.online-user .last-seen {
  font-size: 11px;
  color: #aaa;
}

.online-user .admin-badge {
  font-size: 10px;
  font-weight: bold;
  color: #ffcc00;
  margin-left: auto;
}

/* ===== Badges ===== */
.unread-badge {
  background: #3a82f7;
  color: #fff;
  font-size: 0.75rem;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 12px;
  min-width: 18px;
  text-align: center;
  display: inline-block;
  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  transition: all 0.2s;
}

/* ===== Friend Entries ===== */
.friend-entry {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #1b3a73;
  padding: 8px 12px;
  border-radius: 12px;
  margin-bottom: 6px;
  transition: all 0.2s;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.friend-entry:hover {
  background: #2a4d8c;
  transform: translateX(2px);
}

.friend-entry .avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  margin-right: 8px;
}

.friend-entry button {
  background: #3a82f7;
  border: none;
  border-radius: 6px;
  padding: 4px 10px;
  color: #fff;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

.friend-entry button:hover {
  background: #1e6cd1;
}

/* ===== Friend Controls ===== */
#friendControls {
  display: flex;
  gap: 6px;
  align-items: center;
  margin-bottom: 8px;
}

#friendInput {
  flex: 1;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid #333;
  background: #091f36;
  color: #fff;
}

#addFriendBtn, #toggleDiscoverBtn {
  padding: 8px 10px;
  border-radius: 6px;
  border: none;
  background: linear-gradient(90deg, #386fa4, #2d4a7c);
  color: #fff;
  cursor: pointer;
  font-weight: bold;
}

#addFriendBtn:hover, #toggleDiscoverBtn:hover {
  filter: brightness(1.1);
}

/* ===== Chat All Button ===== */
#chatAllBtn {
  width: 100%;
  padding: 12px;
  margin-top: 14px;
  border: none;
  border-radius: 8px;
  font-weight: bold;
  cursor: pointer;
  color: #fff;
  background: linear-gradient(90deg, #9e363a, #7a272a);
  transition: all 0.2s;
}

#chatAllBtn:hover {
  transform: scale(1.05);
  box-shadow: 0 3px 10px rgba(158,54,58,0.4);
}

/* ===== Chat Container ===== */
#chatContainer {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: linear-gradient(180deg, #091f36, #0f2862);
  color: #f5f5f5;
  margin-right: 0;
  transition: all 0.4s ease;
}

#sidebar.visible ~ #chatContainer {
  margin-right: 360px;
}

/* ===== Tabs ===== */
#tabs {
  display: flex;
  background: #0f2862;
  border-bottom: 1px solid #4f5f76;
  padding: 6px 10px;
  gap: 8px;
}

.tab {
  padding: 8px 14px;
  cursor: pointer;
  background: rgba(15, 40, 98, 0.9);
  border-radius: 10px;
  display: inline-flex;
  align-items: center;
  color: #eee;
  font-size: 14px;
  font-weight: 500;
  gap: 6px;
  transition: all 0.2s;
}

.tab:hover {
  background: #4f5f76;
  transform: translateY(-2px);
}

.tab.active {
  background: #091f36;
  border-bottom: 3px solid #3a82f7;
  font-weight: 600;
  color: #fff;
}

.tab .close-btn {
  margin-left: 8px;
  color: #3a82f7;
  font-size: 13px;
  cursor: pointer;
  transition: color 0.2s;
}

.tab .close-btn:hover {
  color: #ff5c5c;
}

/* ===== Messages ===== */
#notesList {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 18px;
  overflow-y: auto;
}

.note-item {
  max-width: 70%;
  padding: 10px 14px;
  border-radius: 16px;
  font-size: 14px;
  line-height: 1.4;
  display: flex;
  gap: 10px;
  align-items: center;
  box-shadow: 0 3px 6px rgba(0,0,0,0.25);
  transition: transform 0.2s;
}

.note-item:hover {
  transform: translateY(-2px);
}

.note-item img {
  width: 30px;
  height: 30px;
  border-radius: 50%;
}

.note-item:not(.own-message) {
  align-self: flex-start;
  background: #4f5f76;
  border-bottom-left-radius: 4px;
}

.own-message {
  align-self: flex-end;
  background: #0f2862;
  border-bottom-right-radius: 4px;
}

.private-message {
  background: #9e363a;
  color: #fff;
  align-self: center;
  border-radius: 12px;
  font-weight: bold;
}

.admin-message {
  border: 2px solid #ffcc00;
  background: #333366;
  font-weight: bold;
}

.note-item button {
  margin-left: 10px;
  border: none;
  border-radius: 6px;
  background: #9e363a;
  color: #fff;
  padding: 4px 8px;
  font-size: 12px;
  cursor: pointer;
  transition: background 0.2s;
}

.note-item button:hover {
  background: #7a272a;
}

/* ===== Chat Bar ===== */
#chatBar {
  display: flex;
  padding: 12px;
  gap: 8px;
  align-items: center;
  background: rgba(15, 40, 98, 0.9);
  border-top: 1px solid #333;
  backdrop-filter: blur(6px);
  border-radius: 0 0 12px 12px;
}

#username {
  width: 110px;
  padding: 6px;
  border-radius: 8px;
  border: 1px solid #333;
  background: #091f36;
  color: #fff;
  text-align: center;
  font-size: 13px;
  font-weight: 500;
}

#noteInput {
  flex: 1;
  height: 38px;
  padding: 0 12px;
  font-size: 14px;
  border-radius: 8px;
  border: 1px solid #333;
  background: #0f2862;
  color: #fff;
  transition: all 0.2s;
}

#noteInput:focus {
  outline: none;
  border-color: #3a82f7;
  background: #091f36;
}

#sendBtn, #logoutBtn, #attachBtn {
  height: 38px;
  padding: 0 16px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: bold;
  color: #fff;
  background: #3a82f7;
  transition: all 0.2s;
}

#sendBtn:hover, #logoutBtn:hover, #attachBtn:hover {
  transform: translateY(-2px);
  box-shadow: 0 3px 10px rgba(58,130,247,0.4);
}

/* ===== Misc ===== */
.unread-holder {
  display: flex;
  align-items: center;
  margin-left: 8px;
}

.help {
  font-size: 12px;
  color: #ccc;
  margin-top: 8px;
  line-height: 1.3;
}

.help a {
  color: #3a82f7;
}

.timestamp {
  font-size: 11px;
  color: #aaa;
  margin-left: 6px;
}

.typing-indicator {
  font-size: 12px;
  color: #5fa8d3;
  margin-top: 4px;
}

/* ===== Modal (News) ===== */
#newsOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

#newsModal {
  width: min(600px, 90vw);
  max-height: 80vh;
  overflow-y: auto;
  background: #0f2862;
  color: #fff;
  border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  padding: 18px 20px;
}

#newsModal header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

#newsModal h2 {
  margin: 0 0 8px;
}

#closeNewsBtn {
  border: none;
  background: #9e363a;
  color: #fff;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
}

#dontShowNewsBtn {
  border: none;
  background: #4f5f76;
  color: #fff;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  margin-right: 8px;
}
</style>


</head>
<body>
<button id="toggleSidebar">‚ò∞</button>
<div id="sidebar" class="hidden">
  <h3>Friends</h3>
  <div id="friendControls">
    <input id="friendInput" type="text" placeholder="Add friend by username" maxlength="32" />
    <button id="addFriendBtn">Add</button>
    <button id="toggleDiscoverBtn" title="Show/Hide all online users">Discover</button>
  </div>

  <div id="friendsList"></div>

  <h3>Friend Requests</h3>
  <div id="requestsList"></div>

  <h3 style="display:flex;align-items:center;justify-content:space-between;">Discover (All Online)
    <span style="font-size:12px;color:#ccc;">‚Äî filtered to non-friends</span>
  </h3>
  <div id="discoverList"></div>

  <button id="chatAllBtn">Chat All</button>
  <button id="editProfileBtn" style="width:100%; padding:12px; margin-top:8px; border:none; background:#4f5f76; color:#fff; font-weight:bold; border-radius:8px; cursor:pointer;" hidden>
    Edit Profile
  </button>

  <br /><br />
  <input type="color" id="bgSelector" onchange="changeBackground()" />
  <br><br>
  <button id="showNewsBtn" class="action-btn" type="button">Show News</button>

</div>

<div id="chatContainer">
  <div id="tabs"></div>
  <div id="notesList"></div>
    <!-- Place this inside your chat container, e.g., above or below notesList -->

    <div id="typingIndicator" style="font-size:12px; color:#aaa; margin:4px;"></div>
  <div id="chatBar">
    <input id="username" readonly />
    <input type="text" id="noteInput" placeholder="Write a message or paste a link..." />
    <button id="sendBtn">Send</button>
    <button id="attachBtn" title="Paste a URL">üìé</button>
    <button id="logoutBtn">Logout</button>

  </div>
</div>

<!-- News Modal -->
<div id="newsOverlay" role="dialog" aria-modal="true" aria-labelledby="newsTitle">
  <div id="newsModal">
    <header>
      <h2 id="newsTitle">Kitchatty ‚Äî Updates</h2>
      <button id="closeNewsBtn" type="button">Close</button>
    </header>
    <div style="font-size:14px; line-height:1.5;">
      <p><strong>What‚Äôs new:</strong></p>
      <ul>
        <li>‚ú® Brand new Friends system (add/accept/remove + requests)</li>
        <li>üóÇÔ∏è Sidebar is decluttered ‚Äî only shows your friends by default</li>
        <li>üõ°Ô∏è Profanity filter & 350 character limit</li>
        <li>üñºÔ∏è Free attachments via pasted links (Imgur/Postimages etc.)</li>
        <li>üì£ This news pops up the first time you open the page</li>
      </ul>
      <p style="opacity:.8;">Tip: Use <em>Discover</em> to see everyone currently online and add them as friends.</p>
      <div style="margin-top:10px; display:flex; justify-content:flex-end; gap:8px;">
        <button id="dontShowNewsBtn" type="button">Don‚Äôt show again</button>
        <button id="ackNewsBtn" class="action-btn" type="button">Got it</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ===== Firebase ===== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import {
  getFirestore, collection, addDoc, onSnapshot,
  deleteDoc, doc, query, orderBy, setDoc,
  updateDoc, arrayUnion, arrayRemove, serverTimestamp, getDoc
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

/* ===== Firebase (Spark-plan friendly: no Storage) ===== */
const firebaseConfig = {
  apiKey: "AIzaSyBXhiyGWev_pgR04Xqwq-09cE_oyrLWnU8",
  authDomain: "kitisnotebook.firebaseapp.com",
  projectId: "kitisnotebook",
  // storageBucket intentionally omitted for free plan
  messagingSenderId: "450680847245",
  appId: "1:450680847245:web:2e4ebb71ccd3a7920bdbc4",
  measurementId: "G-W3ZVV6N6KK"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ===== Admin & login ===== */
const ADMIN_USER = "kitis";
let isAdmin = false;
const loggedInUser = localStorage.getItem("loggedInUser");
if (!loggedInUser) window.location.href = "login.html";
(document.getElementById("username")).value = loggedInUser;
if (loggedInUser === ADMIN_USER) isAdmin = true;
// Ensure my user doc exists so friends can reference me
await setDoc(doc(db, "users", loggedInUser), { createdAt: Date.now() }, { merge: true });

/* ===== Helpers ===== */
const looksLikeUrl = (text = "") => /^https?:\/\/\S+$/i.test(text.trim());
const isImageUrl = (str = "") => /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(str.split(/[?#]/)[0]);
const isGroupKey = (k) => typeof k === "string" && k.startsWith("group:");
const groupNameFromKey = (k) => (k.split(":")[1] || "").trim();
const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

function formatLastSeen(ms) {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) return "just now";
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} min ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hr ago`;
  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}

/* ===== Profanity filter ===== */
const bannedWords = [
  "fuck","bitch","pussy","cock","cum","slut","whore",
  "france","french","british","asshole","dick","cunt","bastard","motherfucker",
  "nigger","nigga","chink","spic","fag","faggot","retard"
];
function filterProfanity(text) {
  let filtered = text;
  bannedWords.forEach((w) => {
    const regex = new RegExp(w, "gi");
    filtered = filtered.replace(regex, "****");
  });
  return filtered;
}

/* ===== Presence ===== */
const friendsList = document.getElementById("friendsList");
const requestsList = document.getElementById("requestsList");
const discoverList = document.getElementById("discoverList");

// Track who is online + their meta
let presence = {}; // { username: { lastActive:number, avatar:string } }

// Friends state
let friendsAccepted = new Set();
let friendsPendingOut = new Set(); // I sent
let friendsRequestedIn = new Set(); // They sent

// Listen to online presence
onSnapshot(collection(db, "onlineUsers"), (snapshot) => {
  const now = Date.now();
  const map = {};
  snapshot.forEach((docSnap) => {
    const data = docSnap.data();
    const user = data.username;
    if (!user || user === loggedInUser) return; // hide self
    map[user] = {
      lastActive: data.lastActive || 0,
      avatar: data.avatar || `https://i.pravatar.cc/30?u=${user}`,
      online: now - (data.lastActive || 0) <= 60 * 1000
    };
  });
  presence = map;
  renderFriends();
  renderDiscover();
});

/* ===== Friends subcollection ===== */
const myFriendsCol = collection(db, "users", loggedInUser, "friends");

onSnapshot(myFriendsCol, (snap) => {
  friendsAccepted = new Set();
  friendsPendingOut = new Set();
  friendsRequestedIn = new Set();

  snap.forEach((docSnap) => {
    const friend = docSnap.id;
    const data = docSnap.data();
    const status = (data && data.status) || "";
    if (status === "accepted") friendsAccepted.add(friend);
    else if (status === "pending") friendsPendingOut.add(friend);
    else if (status === "requested") friendsRequestedIn.add(friend);
  });

  renderFriends();
  renderRequests();
  renderDiscover();
});



async function respondToFriendRequest(fromUser, accept) {
  const myRef = doc(db, "users", loggedInUser, "friends", fromUser);
  const theirRef = doc(db, "users", fromUser, "friends", loggedInUser);
  try {
    if (accept) {
      await updateDoc(myRef, { status: "accepted" });
      await updateDoc(theirRef, { status: "accepted" });
    } else {
      await deleteDoc(myRef);
      await deleteDoc(theirRef);
    }
  } catch (e) {
    console.error(e);
    alert("Failed to update request.");
  }
}

async function cancelFriendRequest(user) {
  const myRef = doc(db, "users", loggedInUser, "friends", user);
  const theirRef = doc(db, "users", user, "friends", loggedInUser);
  try {
    await deleteDoc(myRef);
    await deleteDoc(theirRef);
  } catch (e) {
    console.error(e);
    alert("Failed to cancel request.");
  }
}

async function removeFriend(user) {
  if (!confirm(`Remove ${user} from friends?`)) return;
  const myRef = doc(db, "users", loggedInUser, "friends", user);
  const theirRef = doc(db, "users", user, "friends", loggedInUser);
  try {
    await deleteDoc(myRef);
    await deleteDoc(theirRef);
  } catch (e) {
    console.error(e);
    alert("Failed to remove friend.");
  }
}

/* ===== Rendering ===== */
function sortUsersByPresence(usernames) {
  const now = Date.now();
  return [...usernames].sort((a, b) => {
    const A = presence[a] || {}; const B = presence[b] || {};
    const aOnline = A.lastActive ? now - A.lastActive <= 60*1000 : false;
    const bOnline = B.lastActive ? now - B.lastActive <= 60*1000 : false;
    if (aOnline && !bOnline) return -1;
    if (!aOnline && bOnline) return 1;
    return (B.lastActive || 0) - (A.lastActive || 0);
  });
}

function buildUserRow(user, opts = {}) {
  const meta = presence[user] || { lastActive: 0, avatar: `https://i.pravatar.cc/30?u=${user}` };
  const div = document.createElement("div");
  div.className = "online-user";
  div.dataset.user = user;

  const avatar = document.createElement("img");
  avatar.src = meta.avatar;
  avatar.className = "avatar";

  const info = document.createElement("span");
  info.color = 'green'
  info.textContent = `${user} ${meta.online ? "online" : "(last seen " + timeAgo(meta.lastActive) + ")"}`;

  const right = document.createElement("div");
  right.className = "actions";

  // Add optional action buttons
  (opts.buttons || []).forEach((btnDef) => {
    const b = document.createElement("button");
    b.className = "action-btn";
    b.textContent = btnDef.text;
    b.onclick = (e) => {
      e.stopPropagation(); // stop row click
      btnDef.onClick && btnDef.onClick();
    };
    right.appendChild(b);
  });

  div.appendChild(avatar);
  div.appendChild(info);
  div.appendChild(right);

  // Only allow row click if not explicitly disabled
  if (!opts.preventRowClick) {
    div.onclick = () => openTab(user);
  }

  return div;
}



function renderFriends() {
  friendsList.innerHTML = "";

  // All Chat pseudo-row
  const allDiv = document.createElement("div");
  allDiv.className = "online-user";
  allDiv.dataset.user = "all";
  const leftAll = document.createElement("div");
  leftAll.style.display = "flex";
  leftAll.style.flexDirection = "column";
  const labelAll = document.createElement("span");
  labelAll.textContent = "All Chat";
  leftAll.appendChild(labelAll);
  allDiv.appendChild(leftAll);
  const rightAll = document.createElement("div");
  rightAll.style.display = "flex";
  rightAll.style.alignItems = "center";
  const unreadHolderAll = document.createElement("span");
  unreadHolderAll.className = "unread-holder";
  rightAll.appendChild(unreadHolderAll);
  allDiv.appendChild(rightAll);
  allDiv.onclick = () => openTab("all");
  friendsList.appendChild(allDiv);
  updateUnreadBadge("all");

  const sorted = sortUsersByPresence(friendsAccepted);
  sorted.forEach((user) => {
    const row = buildUserRow(user, {
      buttons: [
        { text: "Chat", title: "Open chat", onClick: () => openTab(user) },
        { text: "‚àí", title: "Remove friend", onClick: () => removeFriend(user) },
      ],
    });
    friendsList.appendChild(row);
    updateUnreadBadge(user);
  });

  if (!sorted.length) {
    const hint = document.createElement("div");
    hint.style.fontSize = "12px";
    hint.style.color = "#ccc";
    hint.style.marginTop = "6px";
    hint.innerHTML = "No friends yet. Use <strong>Discover</strong> or add by username above.";
    friendsList.appendChild(hint);
  }
}

function renderRequests() {
  requestsList.innerHTML = "";

  // Incoming requests (requested -> me)
sortUsersByPresence(friendsRequestedIn).forEach((user) => {
  const row = buildUserRow(user, {
    buttons: [
      { text: "Accept", onClick: () => respondToFriendRequest(user, true) },
      { text: "Reject", onClick: () => respondToFriendRequest(user, false) },
    ],
    preventRowClick: true
  });
  requestsList.appendChild(row);
});

  // Outgoing pending (I sent)
  sortUsersByPresence(friendsPendingOut).forEach((user) => {
    const row = buildUserRow(user, {
      buttons: [
        { text: "Pending‚Ä¶", title: "Waiting for response", onClick: () => {} },
        { text: "Cancel", onClick: () => cancelFriendRequest(user) },
      ],
      preventRowClick: true
    });
    requestsList.appendChild(row);
  });

  // Show placeholder if no requests
  if (!friendsRequestedIn.size && !friendsPendingOut.size) {
    const none = document.createElement("div");
    none.style.fontSize = "12px";
    none.style.color = "#ccc";
    none.textContent = "No pending requests.";
    requestsList.appendChild(none);
  }
}


function renderDiscover() {
  const allOnline = new Set(Object.keys(presence));
  const notFriends = [...allOnline].filter(
    (u) => !friendsAccepted.has(u) && u !== loggedInUser
  );
  const sorted = sortUsersByPresence(notFriends);

  discoverList.innerHTML = "";
  sorted.forEach((user) => {
    const alreadyPending = friendsPendingOut.has(user);
    const alreadyIncoming = friendsRequestedIn.has(user);

    const row = buildUserRow(user, {
      buttons: [
        alreadyPending
          ? { text: "Pending‚Ä¶", onClick: () => {} }
          : alreadyIncoming
          ? { text: "Accept", onClick: () => respondToFriendRequest(user, true) }
          : { text: "Add", onClick: () => sendFriendRequest(user) },
      ],
      preventRowClick: true, // disable row click for discover list
    });

    discoverList.appendChild(row);
  });

  if (!sorted.length) {
    const msg = document.createElement("div");
    msg.style.fontSize = "12px";
    msg.style.color = "#ccc";
    msg.textContent = "No one to discover right now.";
    discoverList.appendChild(msg);
  }
}


async function sendFriendRequest(toUser) {
  if (!toUser || toUser === loggedInUser) return;
  const myRef = doc(db, "users", loggedInUser, "friends", toUser);
  const theirRef = doc(db, "users", toUser, "friends", loggedInUser);

  try {
    await setDoc(myRef, { status: "pending" });
    await setDoc(theirRef, { status: "requested" });
  } catch (err) {
    console.error(err);
    alert("Failed to send friend request.");
  }
}

/* Controls */
document.getElementById("addFriendBtn").onclick = () => {
  const input = document.getElementById("friendInput");
  sendFriendRequest(input.value);
  input.value = "";
};

const toggleDiscoverBtn = document.getElementById("toggleDiscoverBtn");
toggleDiscoverBtn.onclick = () => {
  const isHidden = getComputedStyle(discoverList).display === "none";
  discoverList.style.display = isHidden ? "block" : "none";
};

/* ===== Presence: mark myself online ===== */
async function goOnline() {
  const userRef = doc(db, "onlineUsers", loggedInUser);
  await setDoc(userRef, {
    username: loggedInUser,
    lastActive: Date.now(),
    avatar: "https://i.pravatar.cc/30?u=" + loggedInUser,
  });
}
goOnline();
setInterval(async () => {
  const userRef = doc(db, "onlineUsers", loggedInUser);
  await setDoc(
    userRef,
    { username: loggedInUser, lastActive: Date.now(), avatar: `https://i.pravatar.cc/30?u=${loggedInUser}` },
    { merge: true }
  );
}, 30000);

/* Optional profile live updates for current user avatar/status (guarded) */
onSnapshot(doc(db, "profiles", loggedInUser), (snap) => {
  if (!snap.exists()) return;
  const data = snap.data();
  const userDiv = document.querySelector(`.online-user[data-user="${CSS.escape(loggedInUser)}"]`);
  if (!userDiv) return; // we don't render self in lists
  const img = userDiv.querySelector("img");
  if (img) img.src = data.avatar || `https://i.pravatar.cc/30?u=${loggedInUser}`;
  const label = userDiv.querySelector("span");
  if (label) label.textContent = `${loggedInUser} - ${data.status || ""}`;
});

/* ===== Groups: UI + Data ===== */
const sidebar = document.getElementById("sidebar");


const groupsHeader = document.createElement("h3");
groupsHeader.textContent = "Groups";
const groupsList = document.createElement("div");
groupsList.id = "groupsList";

// + New Group button
const newGroupBtn = document.createElement("button");
newGroupBtn.id = "newGroupBtn";
newGroupBtn.textContent = "+ New Group";
newGroupBtn.style.cssText = `
  width: 100%; padding: 12px; margin-top: 8px; border: none;
  background: linear-gradient(90deg, #386fa4, #2d4a7c); color: #fff;
  font-weight: bold; border-radius: 8px; cursor: pointer;
  transition: transform .2s, box-shadow .2s;
`;
newGroupBtn.onmouseenter = () => (newGroupBtn.style.boxShadow = "0 3px 10px rgba(56,111,164,0.4)");
newGroupBtn.onmouseleave = () => (newGroupBtn.style.boxShadow = "");

// Insert into sidebar
discoverList.insertAdjacentElement("afterend", groupsHeader);
groupsHeader.insertAdjacentElement("afterend", groupsList);
groupsList.insertAdjacentElement("afterend", newGroupBtn);

// Data structures
let myGroups = new Set();                 // e.g., "group:friends"
let groupsMeta = {};                      // key -> { id, members, createdBy, createdAt }

function parseMembers(raw) {
  if (!raw) return [];
  return Array.from(new Set(
    raw.split(",").map(s => s.trim()).filter(Boolean)
  )).filter(u => u.length <= 32);
}

// Event delegation for all group items (dynamically created)
groupsList.addEventListener("click", (e) => {
  const groupEl = e.target.closest(".group-entry");
  if (!groupEl) return;

  const groupName = groupEl.dataset.group;
  if (!groupName) return;

  openTab(`group:${groupName}`);
});

// Create a new group
newGroupBtn.onclick = async () => {
  let name = prompt("Enter a group name (letters, numbers, -, _ ; max 30 chars):");
  if (!name) return;
  name = name.trim().toLowerCase().replace(/[^\w-]+/g, "-").replace(/^-+|-+$/g, "");
  if (!name) return alert("Invalid name.");
  if (name.length > 30) name = name.slice(0, 30);

  const extra = prompt("Add members (comma-separated usernames), optional:");
  const members = parseMembers(extra).filter(u => u !== loggedInUser);

  try {
    await setDoc(doc(db, "groups", name), {
      members: [loggedInUser],
      createdBy: loggedInUser,
      createdAt: Date.now()
    }, { merge: true });

    if (members.length) {
      await updateDoc(doc(db, "groups", name), { members: arrayUnion(...members) });
    }

    // Add group to UI immediately
    const groupItem = document.createElement("div");
    groupItem.className = "group-entry";
    groupItem.dataset.group = name;
    groupItem.textContent = name;
    groupItem.style.cssText = `
      padding: 8px 12px; margin-bottom: 6px;
      border-radius: 10px; background: #1b3a73;
      cursor: pointer; transition: all 0.2s;
    `;
    groupItem.onmouseenter = () => groupItem.style.background = "#2a4d8c";
    groupItem.onmouseleave = () => groupItem.style.background = "#1b3a73";

    groupsList.appendChild(groupItem);

    openTab(`group:${name}`);
  } catch (e) {
    console.error(e);
    alert("Could not create group. Check console for details.");
  }
};

// Live groups list (incremental render could be added later; keep simple for now)
onSnapshot(collection(db, "groups"), (snap) => {
  groupsList.innerHTML = "";
  myGroups = new Set();
  groupsMeta = {};

  snap.forEach((docSnap) => {
    const g = docSnap.data();
    const id = docSnap.id;
    const key = `group:${id}`;
    if (!Array.isArray(g.members)) return;

    if (g.members.includes(loggedInUser)) {
      myGroups.add(key);
      groupsMeta[key] = { id, ...g };

      const div = document.createElement("div");
      div.className = "online-user";
      div.dataset.user = key;

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.flexDirection = "column";
      const label = document.createElement("span");
      label.textContent = `#${id}`;
      left.appendChild(label);

      const small = document.createElement("span");
      small.className = "last-seen";
      small.textContent = `${g.members.length} member${g.members.length === 1 ? "" : "s"}`;
      left.appendChild(small);
      div.appendChild(left);

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";

      const unreadHolder = document.createElement("span");
      unreadHolder.className = "unread-holder";
      right.appendChild(unreadHolder);
        
      const mkBtn = (txt, title) => {
        const b = document.createElement("button");
        b.textContent = txt;
        b.title = title;
        b.className = "action-btn";
        return b;
      };

      const inviteBtn = mkBtn("Ôºã", "Invite members");
      inviteBtn.onclick = async (e) => {
        e.stopPropagation();
        const raw = prompt("Usernames to invite (comma-separated):");
        const toAdd = parseMembers(raw).filter(Boolean);
        if (!toAdd.length) return;
        try { await updateDoc(doc(db, "groups", id), { members: arrayUnion(...toAdd) }); }
        catch (err) { console.error(err); alert("Failed to invite."); }
      };
      right.appendChild(inviteBtn);

      const leaveBtn = mkBtn("‚éã", "Leave group");
      leaveBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm(`Leave #${id}?`)) return;
        try {
          await updateDoc(doc(db, "groups", id), { members: arrayRemove(loggedInUser) });
          if (activeTab === key) {
            activeTab = "all"; highlightActiveTab(); displayMessages();
          }
        } catch (err) { console.error(err); alert("Failed to leave."); }
      };
      right.appendChild(leaveBtn);

      const canDelete = (g.createdBy === loggedInUser) || isAdmin;
      if (canDelete) {
        const delBtn = mkBtn("üóë", "Delete group");
        delBtn.onclick = async (e) => {
          e.stopPropagation();
          if (!confirm(`Delete #${id} for everyone? This removes history (within retention window).`)) return;
          try {
            await deleteDoc(doc(db, "groups", id));
            if (activeTab === key) {
              activeTab = "all"; highlightActiveTab(); displayMessages();
            }
          } catch (err) { console.error(err); alert("Failed to delete group."); }
        };
        right.appendChild(delBtn);
      }

      div.appendChild(right);
      div.onclick = () => openTab(key);

      groupsList.appendChild(div);
      updateUnreadBadge(key);
    }
  });
});

/* ===== Tabs ===== */
const tabsContainer = document.getElementById("tabs");
let openTabs = {};
let activeTab = "all";

function labelForTab(key) {
  if (key === "all") return "All Chat";
  if (isGroupKey(key)) return `#${groupNameFromKey(key)}`;
  return key;
}

function openTab(key) {
  if (!openTabs[key]) {
    const tab = document.createElement("div");
    tab.className = "tab" + (key === activeTab ? " active" : "");
    tab.dataset.user = key;
    tab.textContent = labelForTab(key);

    if (key !== "all") {
      const closeBtn = document.createElement("span");
      closeBtn.textContent = "‚úñ";
      closeBtn.className = "close-btn";
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        tabsContainer.removeChild(tab);
        delete openTabs[key];
        if (activeTab === key) { activeTab = "all"; highlightActiveTab(); displayMessages(); }
      };
      tab.appendChild(closeBtn);
    }

    tab.onclick = () => {
      activeTab = key;
      if (unreadCounts[key]) unreadCounts[key] = 0;
      if (unreadMessageIds[key]) unreadMessageIds[key].clear();
      updateUnreadBadge(key);
      highlightActiveTab();
      displayMessages();
    };

    openTabs[key] = tab;
    tabsContainer.appendChild(tab);
    updateUnreadBadge(key);
  }

  activeTab = key;
  if (unreadCounts[key]) unreadCounts[key] = 0;
  if (unreadMessageIds[key]) unreadMessageIds[key].clear();
  updateUnreadBadge(key);
  highlightActiveTab();
  displayMessages();
}
function highlightActiveTab() {
  Object.values(openTabs).forEach((tab) => tab.classList.remove("active"));
  if (openTabs[activeTab]) openTabs[activeTab].classList.add("active");
}
// --- Unified sendMessage with typing + timestamp support ---
async function sendMessage() {
  let text = document.getElementById("noteInput").value.trim();
  if (!text) return;

  const isDM = !isGroupKey(activeTab) && activeTab !== "all";
  const isFriend = friendsAccepted.has(activeTab);

  if (isDM && !isFriend) {
    alert("You can only message users you are friends with.");
    return;
  }

  // Prevent posting to groups you left
  if (isGroupKey(activeTab) && !myGroups.has(activeTab)) {
    alert("You are not a member of this group.");
    return;
  }

  const targetIsGroup = isGroupKey(activeTab);
  const groupId = targetIsGroup ? groupNameFromKey(activeTab) : null;

  // Pick the right collection
  const msgCol = targetIsGroup
    ? collection(db, "groups", groupId, "messages")
    : collection(db, "messages");

  // Handle URLs as attachments
  if (looksLikeUrl(text)) {
    await addDoc(msgCol, {
      text: "",
      from: loggedInUser,
      to: activeTab,
      timestamp: Date.now(),
      fileURL: text,
      fileName: text.split("/").pop().split("?")[0],
    });
    document.getElementById("noteInput").value = "";
    // reset typing
    await setDoc(doc(db, "presence", loggedInUser), { typing: false }, { merge: true });
    return;
  }

  const maxLength = 350;
  if (text.length > maxLength) {
    alert(`Message too long! Limit is ${maxLength} characters.`);
    return;
  }

  text = filterProfanity(text);

  await addDoc(msgCol, {
    text,
    from: loggedInUser,
    to: activeTab,
    timestamp: Date.now(),
  });

  document.getElementById("noteInput").value = "";

  // reset typing after sending
  await setDoc(doc(db, "presence", loggedInUser), { typing: false }, { merge: true });
}


const toggleBtn = document.getElementById("toggleSidebar");
const chat = document.getElementById("chatContainer");

// Make sure sidebar starts hidden
sidebar.classList.add("hidden");
chat.style.marginRight = "0";

toggleBtn.addEventListener("click", () => {
  const isHidden = sidebar.classList.contains("hidden");

  if (isHidden) {
    // Show sidebar
    sidebar.classList.remove("hidden");
    sidebar.classList.add("visible");
    chat.style.marginRight = sidebar.offsetWidth + "px";
  } else {
    // Hide sidebar
    sidebar.classList.remove("visible");
    sidebar.classList.add("hidden");
    chat.style.marginRight = "0";
  }
});


document.getElementById("sendBtn").onclick = sendMessage;
document.getElementById("noteInput").addEventListener("keydown", (e) => {
  if (e.key === "Enter") { e.preventDefault(); sendMessage(); }
});

const q = query(collection(db, "messages"), orderBy("timestamp"));
onSnapshot(q, (snapshot) => {
  snapshot.docChanges().forEach((change) => {
    const data = change.doc.data();
    const id = change.doc.id;

    if (change.type === "added") {
      if (!data || typeof data.timestamp !== "number") return;
      mergeMessage({ id, data });
    }

    if (change.type === "modified") {
      if (!data || typeof data.timestamp !== "number") return;
      mergeMessage({ id, data }); // update content if edited
    }

    if (change.type === "removed") {
      // Remove from messagesByTab
      Object.keys(messagesByTab).forEach((key) => {
        messagesByTab[key] = messagesByTab[key].filter(m => m.id !== id);
        // Also update unread if needed
        if (unreadMessageIds[key]) unreadMessageIds[key].delete(id);
      });
    }
  });

  displayMessages();
});


/* ===== Group message listeners ===== */
let groupUnsubs = {};

function setupGroupListeners() {
  // remove old listeners
  Object.values(groupUnsubs).forEach(unsub => unsub());
  groupUnsubs = {};

  myGroups.forEach((key) => {
  const groupId = groupNameFromKey(key);
  const q = query(collection(db, "groups", groupId, "messages"), orderBy("timestamp"));

  groupUnsubs[key] = onSnapshot(q, (snapshot) => {
  snapshot.docChanges().forEach((change) => {
    const data = change.doc.data();
    const id = change.doc.id;

    if (change.type === "added" || change.type === "modified") {
      if (!data || typeof data.timestamp !== "number") return;
      mergeMessage({ id, data });
    }

    if (change.type === "removed") {
      if (!messagesByTab[key]) return;
      messagesByTab[key] = messagesByTab[key].filter(m => m.id !== id);
      if (unreadMessageIds[key]) unreadMessageIds[key].delete(id);
    }
  });

  displayMessages();
});

});

}

// Call it whenever groups membership changes
onSnapshot(collection(db, "groups"), (snap) => {
  // ‚Ä¶ your existing groups list rebuild ‚Ä¶
  setupGroupListeners();
});

/* ===== Messages ===== */
const notesList = document.getElementById("notesList");
let allMessages = [];  // ‚Üê Add this so displayMessages can use it

/* Unread tracking */
let unreadCounts = {};
let unreadMessageIds = {}; // { key: Set<messageId> }

// Track messages separately to avoid duplicates
let messagesByTab = {}; // key = "all", username, or group:groupName, value = array of messages

function displayMessages() {
  notesList.innerHTML = "";

  // Get the messages for the current tab only
  const tabKey = activeTab;
  const messages = messagesByTab[tabKey] || [];

  messages.forEach(({ id, data }) => {
    renderMessage({ id }, data);

    // Mark as read in unread tracking
    if (unreadMessageIds[tabKey]) unreadMessageIds[tabKey].delete(id);
  });

  notesList.scrollTop = notesList.scrollHeight;

  // Update unread badges
  Object.keys(unreadCounts).forEach((key) => updateUnreadBadge(key));
}

// Add a helper to merge new messages into messagesByTab
function mergeMessage(msg) {
  const { id, data } = msg;
  let key;

  if (isGroupKey(data.to)) key = data.to;
  else if (data.to === "all") key = "all";
  else key = data.from === loggedInUser ? data.to : data.from;

  if (!messagesByTab[key]) messagesByTab[key] = [];
  messagesByTab[key] = messagesByTab[key].filter(m => m.id !== id); // remove duplicates
  messagesByTab[key].push(msg);

  // Track unread
  const isDMToMe = key !== "all" && !isGroupKey(key) && data.to === loggedInUser && data.from !== loggedInUser;
  if ((isDMToMe || (key === "all" && data.from !== loggedInUser) || (isGroupKey(key) && data.from !== loggedInUser && !myGroups.has(key)))) {
    if (!unreadMessageIds[key]) unreadMessageIds[key] = new Set();
    if (!unreadMessageIds[key].has(id)) {
      unreadMessageIds[key].add(id);
      unreadCounts[key] = (unreadCounts[key] || 0) + 1;
    }
  }
}


function renderMessage(docSnap, data) {
  const now = Date.now();
  const ONE_HOUR = 60 * 60 * 1000;

  // Convert Firestore Timestamp to milliseconds if necessary
  let msgTime = data.timestamp;
  if (msgTime && typeof msgTime.toMillis === "function") msgTime = msgTime.toMillis();

  // --- Auto-delete old messages in background ---
  if (msgTime && now - msgTime > ONE_HOUR) {
    (async () => {
      try {
        const targetCollection = isGroupKey(data.to)
          ? collection(db, "groups", groupNameFromKey(data.to), "messages")
          : collection(db, "messages");

        await deleteDoc(doc(targetCollection, docSnap.id));
        console.log("Auto-deleted old message:", docSnap.id);
      } catch (err) {
        console.error("Failed to auto-delete old message:", err);
      }
    })();
    // DO NOT return ‚Äî we still render the message
  }

  // --- Render message normally ---
  const div = document.createElement("div");
  div.className = "note-item";

  const avatarImg = document.createElement("img");
  avatarImg.src = `https://i.pravatar.cc/30?u=${data.from}`;
  div.appendChild(avatarImg);

  const content = document.createElement("span");

  if (isGroupKey(data.to)) {
    const gName = groupNameFromKey(data.to);
    content.textContent = `#${gName} ‚Ä¢ ${data.from}: ${data.text || (data.fileName ? data.fileName : "")}`;
  } else if (data.to !== "all" && data.to !== loggedInUser && data.from === loggedInUser) {
    content.textContent = `${data.from} ‚Üí ${data.to}: ${data.text || (data.fileName ? data.fileName : "")}`;
  } else {
    content.textContent = `${data.from}: ${data.text || (data.fileName ? data.fileName : "")}`;
  }
  div.appendChild(content);

  // --- File attachments ---
  if (data.fileURL) {
    const sep = document.createTextNode(" ");
    div.appendChild(sep);

    const fileLink = document.createElement("a");
    fileLink.href = data.fileURL;
    fileLink.target = "_blank";
    fileLink.rel = "noopener noreferrer";
    fileLink.textContent = data.fileName || "File";
    fileLink.style.color = "#ffcc00";
    fileLink.style.textDecoration = "underline";
    div.appendChild(fileLink);

    if (isImageUrl(data.fileURL)) {
      const preview = document.createElement("img");
      preview.src = data.fileURL;
      preview.alt = data.fileName || "attachment";
      preview.style.width = "120px";
      preview.style.height = "auto";
      preview.style.borderRadius = "8px";
      preview.style.marginLeft = "8px";
      preview.style.cursor = "pointer";
      preview.onclick = () => window.open(data.fileURL, "_blank");
      div.appendChild(preview);
    }
  }

  // --- Timestamp ---
  if (data.timestamp) {
    const timeSpan = document.createElement("span");
    timeSpan.className = "timestamp";
    timeSpan.style.marginLeft = "8px";
    timeSpan.style.fontSize = "11px";
    timeSpan.style.color = "#aaa";
    timeSpan.textContent = timeAgo(data.timestamp);
    div.appendChild(timeSpan);
  }

  // --- Styling ---
  if (data.from === ADMIN_USER) div.classList.add("admin-message");
  if (data.from === loggedInUser) div.classList.add("own-message");
  else if (data.to === loggedInUser && data.to !== "all") div.classList.add("private-message");

  // --- Delete button ---
  (function() {
    let canDelete = isAdmin || data.from === loggedInUser;

    if (isGroupKey(data.to)) {
      const groupKey = data.to;
      const group = groupsMeta[groupKey];
      if (group && group.createdBy === loggedInUser) canDelete = true;
    }

    if (canDelete) {
      const delBtn = document.createElement("button");
      delBtn.textContent = "Delete";
      delBtn.title = "Delete message";

      delBtn.onclick = async (e) => {
        e.stopPropagation();
        try {
          const targetCollection = isGroupKey(data.to)
            ? collection(db, "groups", groupNameFromKey(data.to), "messages")
            : collection(db, "messages");

          await deleteDoc(doc(targetCollection, docSnap.id));
        } catch (err) {
          console.error(err);
          alert("Failed to delete message.");
        }
      };

      div.appendChild(delBtn);
    }
  })();

  notesList.appendChild(div);
}


function updateUnreadBadge(user) {
  const row = document.querySelector(`.online-user[data-user="${CSS.escape(user)}"]`);
  if (!row) return;

  let count = unreadCounts[user] || 0;

  // Also count messages in DM tabs even if not friends
  if (user !== "all" && !friendsAccepted.has(user)) {
    const messages = messagesByTab[user] || [];
    count = messages.filter(m => m.from === user && m.to === loggedInUser).length;
  }

  let holder = row.querySelector(".unread-holder");
  if (!holder) {
    holder = document.createElement("span");
    holder.className = "unread-holder";
    row.appendChild(holder);
  }

  holder.innerHTML = "";
  if (count > 0) {
    const badge = document.createElement("span");
    badge.className = "unread-badge";
    badge.textContent = count;
    holder.appendChild(badge);
  }
}

/* Init */
document.getElementById("chatAllBtn").onclick = () => openTab("all");
openTab("all");

window.addEventListener("DOMContentLoaded", () => {
  const logoutBtn = document.getElementById("logoutBtn");
  if (logoutBtn) {
    logoutBtn.onclick = async () => {
      const user = localStorage.getItem("loggedInUser");
      if (!user) {
        window.location.href = "login.html";
        return;
      }

      try {
        // Mark offline in presence
        await setDoc(doc(db, "onlineUsers", user), { online: false }, { merge: true });
      } catch (err) {
        console.warn("Logout presence update failed:", err);
      } finally {
        localStorage.removeItem("loggedInUser"); // clear session
        window.location.href = "login.html";     // back to login screen
      }
    };
  }
});


/* Attachments (paste a URL) */
const attachBtn = document.getElementById("attachBtn");
attachBtn.onclick = async () => {
  const url = prompt("Paste a direct link to an image/file (e.g., https://i.imgur.com/abc123.png):");
  if (!url) return;
  await addDoc(collection(db, "messages"), {
    text: "",
    from: loggedInUser,
    to: activeTab,
    timestamp: Date.now(),
    fileURL: url,
    fileName: url.split("/").pop().split("?")[0],
  });
};

/* Inline color picker */
window.changeBackground = function changeBackground() {
  const notesList2 = document.getElementById("notesList");
  const val = document.getElementById("bgSelector").value;
  notesList2.style.backgroundColor = val;
};

/* News modal behavior */
const NEWS_VERSION = "1"; // bump when you change content
const newsOverlay = document.getElementById("newsOverlay");
const showNews = () => { newsOverlay.style.display = "flex"; };
const hideNews = () => { newsOverlay.style.display = "none"; };

// Open once if not seen
if (localStorage.getItem("kitchatty_news_version") !== NEWS_VERSION) {
  showNews();
}

document.getElementById("closeNewsBtn").onclick = hideNews;
document.getElementById("ackNewsBtn").onclick = () => { hideNews(); localStorage.setItem("kitchatty_news_version", NEWS_VERSION); };
document.getElementById("dontShowNewsBtn").onclick = () => { localStorage.setItem("kitchatty_news_version", NEWS_VERSION); hideNews(); };
document.getElementById("showNewsBtn").onclick = showNews;

// Escape key closes
window.addEventListener("keydown", (e) => { if (e.key === "Escape") hideNews(); });

/* Lightweight runtime checks */
console.assert(typeof window.changeBackground === "function", "changeBackground not attached to window");
console.assert(typeof addDoc === "function", "Firestore import missing");

// Utility: how long ago
function timeAgo(ts) {
  const seconds = Math.floor((Date.now() - ts) / 1000);
  if (seconds < 60) return "just now";
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} minute${minutes > 1 ? "s" : ""} ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hour${hours > 1 ? "s" : ""} ago`;
  const days = Math.floor(hours / 24);
  return `${days} day${days > 1 ? "s" : ""} ago`;
}

const messageInput = document.getElementById("noteInput");
const typingIndicator = document.getElementById("typingIndicator");

let isTyping = false;
let lastTyped = 0;
const TYPING_DELAY = 3000; // 3 seconds inactivity before local timer
const CHECK_INTERVAL = 7000; // 7 seconds to verify typing

// --- Update typing state locally ---
messageInput.addEventListener("input", () => {
  lastTyped = Date.now();

  if (!isTyping) {
    isTyping = true;
    setDoc(doc(db, "presence", loggedInUser), {
      typing: true,
      lastUpdate: lastTyped
    }, { merge: true });
  }
});

// --- Periodically check if user stopped typing ---
setInterval(() => {
  if (isTyping && Date.now() - lastTyped > TYPING_DELAY) {
    isTyping = false;
    setDoc(doc(db, "presence", loggedInUser), {
      typing: false,
      lastUpdate: Date.now()
    }, { merge: true });
  }
}, CHECK_INTERVAL);

// --- Watch all users' typing status ---
function watchAllTypingStatus() {
  onSnapshot(collection(db, "presence"), (snapshot) => {
    const now = Date.now();
    const activeTyping = [];

    snapshot.docs.forEach(docSnap => {
      const data = docSnap.data();
      const user = docSnap.id;

      // Only show typing if updated in last 7s and not yourself
      if (data?.typing && data.lastUpdate && now - data.lastUpdate < CHECK_INTERVAL && user !== loggedInUser) {
        activeTyping.push(user);
      }
    });

    typingIndicator.textContent = activeTyping.length
      ? activeTyping.join(", ") + " is typing..."
      : "";
  });
}

// Start watching all users
watchAllTypingStatus();


// --- Listen for new messages in a chat ---
function watchMessages(chatId) {
  onSnapshot(
    collection(db, "chats", chatId, "messages"),
    (snap) => {
      messagesContainer.innerHTML = "";
      snap.forEach((docSnap) => {
        renderMessage(docSnap.data());
      });
    }
  );
}

</script>

</body>
</html>
